<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring入门]]></title>
    <url>%2F2019%2F07%2F30%2FSpring%2F</url>
    <content type="text"><![CDATA[Spring介绍 Spring诞生: 创建Spring的目的就是用来代替更加重量级的企业级java技术 简化java的开发 基于POJO轻量级和最小侵入式开发 通过依赖注入和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和模板减少板式代码 侵入式概念 Spring是一种非侵入式的框架 侵入式 对于EJB, Struts2等一些传统的框架, 通常是要实现特定的接口, 继承特定的类才能增强功能 改变了java类的结构 非侵入式 对于Hibernate, Spring等框架, 对现有的类结构没有影响, 就能够增强JavaBean的功能 松耦合 前面我们在写程序的时候, 都是面向接口编程, 通过DaoFactory等方法来实现松耦合 1234567private CategoryDao categoryDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.CategoryDAOImpl", CategoryDao.class); private BookDao bookDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.BookDaoImpl", BookDao.class); private UserDao userDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.UserDaoImpl", UserDao.class); private OrderDao orderDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.OrderDaoImpl", OrderDao.class); DAO层和Service层通过DaoFactory来实现松耦合 如果Service层直接new DaoBook(), 那么DAO和Service就紧耦合了[Service层依赖于Dao] 而Spring给我们更加合适的方法来实现松耦合, 并且更加灵活, 功能更加强大! —&gt;IOC控制反转 切面编程 切面编程也就是AOP编程, 其实我们在之前也接触过…动态代理就是一种切面编程了… 当时我们使用动态代理+注解的方式给Service层的方法添加权限 12345678910111213141516171819202122@Override @permission("添加分类") /*添加分类*/ public void addCategory(Category category) &#123; categoryDao.addCategory(category); &#125; /*查找分类*/ @Override public void findCategory(String id) &#123; categoryDao.findCategory(id); &#125; @Override @permission("查找分类") /*查看分类*/ public List&lt;Category&gt; getAllCategory() &#123; return categoryDao.getAllCategory(); &#125; /*添加图书*/ @Override public void addBook(Book book) &#123; bookDao.addBook(book); &#125; Controller调用Service的时候, Service返回的是一个代理对象 代理对象得到Controller想要调用的方法, 通过反射来看看该方法上有没有注解 如果有注解的话, 那么就判断该用户是否有权限来调用此方法, 如果没有权限, 就抛出异常给Controller, Controller接收到异常, 就可以提示用户没有权限了. AOP编程可以简单理解成: 在执行某些代码前, 执行另外的代码 Struts2的拦截器也是面向切面编程[在执行Action业务方法之前执行拦截器] Spring也为我们提供更好的方法来实现面向切面编程 引出Spring 在没学Spring的时候, 开发Web项目: 实体类 - - &gt; class User{} daoclass - - &gt; UserDao{ 访问数据库 } service - - &gt; class UserService{ UserDao userDao = new UserDao(); } actionclass UserAction{ UserService userService = new UserService(); } 用户访问: Tomcat -&gt; action -&gt; service -&gt; dao 有几个问题: :对象创建能否写死 :对象创建细节 action 访问时候创建 service 启动时候创建 dao 启动时候创建 action 多个 [维护成员变量] service 一个 [不需要维护公共变量] dao 一个 [不需要维护公共变量 对象数量 创建时间 :对象的依赖关系 action依赖service service依赖dao 对于第一个问题和第三个问题, 可以通过DaoFactory解决. 对于第二个问题, 我们要控制对象的数量和创建时间就有点麻烦了 而Spring框架通过IOC就很好的解决上面的问题 IOC控制反转 Spring的核心思想之一: Inversion of Control, 控制反转 IOC 对象的创建交给外部容器完成, 就是控制反转 Spring使用控制反转来实现对象不用在程序中写死 控制反转解决对象处理问题[把对象交给别人创建] 那么对象和对象之间的依赖关系Spring是怎么做的呢? 依赖注入, dependency injection Spring使用依赖注入来实现对象之间的依赖关系 在创建完对象之后, 对象的关系处理就是依赖注入 控制反转是通过外部容器完成的, 而Spring又为我们提供了这么一个容器, 我们一般将这个容器叫做: IOC容器. 无论是创建对象, 处理对象之间的依赖关系, 对象创建的时间还是对象的数量, 我们都是在Spring为我们提供的IOC容器上配置对象的信息就好了. 那么使用IOC控制反转这一思想有什么作用呢? 来自知乎 我摘取一下核心的部分： ioc的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。 也就是说，甲方要达成某种目的不需要直接依赖乙方，它只需要达到的目的告诉第三方机构就可以了，比如甲方需要一双袜子，而乙方它卖一双袜子，它要把袜子卖出去，并不需要自己去直接找到一个卖家来完成袜子的卖出。它也只需要找第三方，告诉别人我要卖一双袜子。这下好了，甲乙双方进行交易活动，都不需要自己直接去找卖家，相当于程序内部开放接口，卖家由第三方作为参数传入。甲乙互相不依赖，而且只有在进行交易活动的时候，甲才和乙产生联系。反之亦然。这样做什么好处么呢，甲乙可以在对方不真实存在的情况下独立存在，而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。那么交易就能很可靠很灵活的产生和进行了。这就是ioc的核心思想。生活中这种例子比比皆是，支付宝在整个淘宝体系里就是庞大的ioc容器，交易双方之外的第三方，提供可靠性可依赖可灵活变更交易方的资源管理中心。另外人事代理也是，雇佣机构和个人之外的第三方。==========================update=========================== 在以上的描述中，诞生了两个专业词汇，依赖注入和控制反转所谓的依赖注入，则是，甲方开放接口，在它需要的时候，能够讲乙方传递进来(注入)所谓的控制反转，甲乙双方不相互依赖，交易活动的进行不依赖于甲乙任何一方，整个活动的进行由第三方负责管理。 Spring模块 Spring可以分为6大模块 Spring Core Spring的核心功能: IOC容器, 解决对象创建及依赖关系 Spring Web Spring对web模块的支持 可以与Struts整合, 让Struts的action创建交给spring spring mvc模式 Spring DAO Spring对jdbc操作的支持 Spring ORM spring对orm的支持: 既可以与hibernate整合,[session] 也可以使用spring的对hibernate操作的封装 Spring AOP 切面编程 SpringEE Spring对javaEE其他模块的支持 Core模块快速入门 搭建配置环境 引入jar包: 涉及到Spring core的开发jar包有五个: commons-logging-1.1.3.jar 日志 spring-beans-3.2.5.RELEASE.jar bean节点 spring-context-3.2.5.RELEASE.jar spring上下文节点 spring-core-3.2.5.RELEASE.jar spring核心功能 spring-expression-3.2.5.RELEASE.jar spring表达式相关表 编写配置文件: Spring核心的配置文件applicationContext.xml或者叫bean.xml 那这个配置文件怎么写呢？？一般地，我们都知道框架的配置文件都是有约束的…我们可以在spring-framework-3.2.5.RELEASE\docs\spring-framework-reference\htmlsingle\index.html找到XML配置文件的约束 1234567891011&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;/beans&gt; 前面在介绍Spring模块的时候已经说了，Core模块是：IOC容器，解决对象创建和之间的依赖关系。 因此Core模块主要是学习如何得到IOC容器，通过IOC容器来创建对象、解决对象之间的依赖关系、IOC细节。 得到Spring容器对象[IOC]容器 Bean工厂，BeanFactory[功能简单] 应用上下文，ApplicationContext[功能强大，一般我们使用这个] 加载配置文件 通过XmlBeanFactory+配置文件来创建IOC容器 12345//加载Spring的资源文件Resource resource = new ClassPathResource("applicationContext.xml");//创建IOC容器对象【IOC容器=工厂类+applicationContext.xml】BeanFactory beanFactory = new XmlBeanFactory(resource); 直接通过ClassPathXmlApplicationContext对象来获取 12// 得到IOC容器对象ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); 在Spring中总体来看可以通过三种方式来配置对象: 使用XML文件配置 使用注解来配置 使用JavaConfig来配置 XML配置方式 在上面我们已经可以得到IOC对象了. 接下来就是在applicationContext.xml文件中配置信息[让IOC容器根据applicationContext.xml文件来创建对象] 首先我们有个JavaBean的类 12345678910111213141516171819202122public class User &#123; private String id; private String username; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125;&#125; 以前我们是通过new User的方法创建对象的 1User user = new User; 现在我们有了IOC容器, 可以让IOC容器帮我们创建对象了. 在applicationContext.xml文件中配置对应的信息就行了 123456&lt;!-- 使用bean节点来创建对象 id属性标识着对象 name属性代表着要创建对象的类全名 --&gt;&lt;bean id="user" class="User"/&gt; 通过IOC容器对象获取对象 在外界通过IOC容器对象得到User对象 1User user = (User) ac.getBean("user"); 上面我们使用的是IOC通过无参构造函数来创建对象, 我们来回顾一下一般有几种创建对象的方式： 无参构造函数创建对象 带参数的构造函数创建对象 工厂创建对象 静态方法创建对象 非静态方法创建对象 使用无参的构造函数创建对象我们已经会了, 接下来我们看看使用剩下的IOC容器是怎么创建对象的. 带参数的构造函数创建对象 首先, JavaBean要提供带参数的构造函数 1234public User(String id, String username) &#123; this.id = id; this.username = username; &#125; 接下来, 关键是怎么配置xml文件 12345&lt;bean id="user" class="User"&gt; &lt;!--通过constructor这个节点来指定构造函数的参数类型、名称、第几个--&gt; &lt;constructor-arg index="0" name="id" type="java.lang.String" value="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" name="username" type="java.lang.String" value="zhongfucheng"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 在constructor上如果构造函数的值是一个对象，而不是一个普通类型的值，我们就需要用到ref属性了，而不是value属性 比如说：我在User对象上维护了Person对象的值，想要在构造函数中初始化它。因此，就需要用到ref属性了 1234567&lt;bean id="person" class="Person"&gt;&lt;/bean&gt; &lt;bean id="user" class="User" &gt; &lt;!--通过constructor这个节点来指定构造函数的参数类型、名称、第几个--&gt; &lt;constructor-arg index="0" name="id" type="java.lang.String" value="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" name="username" type="java.lang.String" ref="person"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 工厂静态方法创建对象 首先, 使用一个工厂的静态方法返回一个对象 123456public class Factory &#123; public static User getBean() &#123; return new User(); &#125;&#125; 配置文件中使用工厂的静态方法返回对象 1234&lt;!--工厂静态方法创建对象，直接使用class指向静态类，指定静态方法就行了--&gt; &lt;bean id="user" class="Factory" factory-method="getBean" &gt; &lt;/bean&gt; 工厂非静态方法创建对象 首先, 也是通过工厂的非非静态方法来得到一个对象 123456public class Factory &#123; public User getBean() &#123; return new User(); &#125;&#125; 配置文件中使用工厂的非静态方法返回对象 12345&lt;!--首先创建工厂对象--&gt; &lt;bean id="factory" class="Factory"/&gt; &lt;!--指定工厂对象和工厂方法--&gt; &lt;bean id="user" class="User" factory-bean="factory" factory-method="getBean"/&gt; 装载集合 如果对象上的属性或者构造函数拥有集合的时候, 而我们又需要为集合赋值, 那么怎么办？ 在构造函数上，普通类型 12345678 &lt;bean id="userService" class="bb.UserService" &gt; &lt;constructor-arg &gt; &lt;list&gt; //普通类型 &lt;value&gt;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; 在属性上,引用类型 123456&lt;property name="userDao"&gt; &lt;list&gt; &lt;ref&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; 注解方式 通过注解来配置信息就是为了简化IOC容器的配置, 注解可以把对象添加到IOC容器中, 处理对象依赖关系, 我们来看看怎么用吧： 使用注解步骤： 1. 先引入context名称空间 xmlns:context=”http://www.springframework.org/schema/context&quot; 2. 开启注解扫描器 &lt;context:component-scan base-package=&quot;&quot;&gt;&lt;/context:component-scan&gt; 第二种方法:也可以通过自定义扫描类以@CompoentScan修饰来扫描IOC容器的bean对象。。如下代码: 12345678910//表明该类是配置类@Configuration//启动扫描器，扫描bb包下的 //也可以指定多个基础包 //也可以指定类型@ComponentScan("bb")public class AnnotationScan &#123;&#125; 在使用@ComponentScan()这个注解的时候，在测试类上需要@ContextConfiguration这个注解来加载配置类 @ContextConfiguration这个注解又在Spring的test包下 创建对象以及处理对象依赖关系，相关的注解： @ComponentScan扫描器 @Configuration表明该类是配置类 @Component 指定把一个对象加入IOC容器—&gt;@Name也可以实现相同的效果【一般少用】 @Repository 作用同@Component； 在持久层使用 @Service 作用同@Component； 在业务逻辑层使用 @Controller 作用同@Component； 在控制层使用 @Resource 依赖关系 如果@Resource不指定值，那么就根据类型来找，相同的类型在IOC容器中不能有两个 如果@Resource指定了值，那么就根据名字来找 测试代码: UserDao 12345678package aa;import org.springframework.stereotype.Repository;//把对象添加到容器中,首字母会小写@Repositorypublic class UserDao &#123; public void save() &#123; System.out.println("DB:保存用户"); &#125;&#125; userService 1234567891011121314151617181920212223package aa;import org.springframework.stereotype.Service;import javax.annotation.Resource;//把UserService对象添加到IOC容器中,首字母会小写@Servicepublic class UserService &#123; //如果@Resource不指定值，那么就根据类型来找---&gt;UserDao....当然了，IOC容器不能有两个UserDao类型的对象 //@Resource //如果指定了值，那么Spring就在IOC容器找有没有id为userDao的对象。 @Resource(name = "userDao") private UserDao userDao; public void save() &#123; userDao.save(); &#125;&#125; useraction 123456789101112131415161718package aa;import org.springframework.stereotype.Controller;import javax.annotation.Resource;//把对象添加到IOC容器中,首字母会小写@Controllerpublic class UserAction &#123; @Resource(name = "userService") private UserService userService; public String execute() &#123; userService.save(); return null; &#125;&#125; 测试 1234567891011121314151617package aa;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main(String[] args) &#123; // 创建容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext("aa/applicationContext.xml"); UserAction userAction = (UserAction) ac.getBean("userAction"); userAction.execute(); &#125;&#125; 通过java方式 由于Spring的自动装配并不能将第三方库组件装配到应用中, 于是需要显式装配配置. 显示装配有两种方式 通过java代码装配bean 通过XML装配bean Spring In Action作者首推使用自动装配的功能，而后是通过java代码配置bean，最后才用XML文件配置的方式.. 那么怎么通过java代码来配置Bean呢？？ 编写一个java类，使用@Configuration修饰该类 被@Configuration修饰的类就是配置类 编写配置类: 1234@org.springframework.context.annotation.Configuration public class Configuration &#123; &#125; 使用配置类创建bean: 使用@Bean来修饰方法，该方法返回一个对象 不管方法体内的对象是怎么创建的，Spring可以获取得到对象就行了 Spring内部会将该对象加入到Spring容器中 容器中bean的ID默认为方法名 123456789101112@org.springframework.context.annotation.Configurationpublic class Configuration &#123; @Bean public UserDao userDao() &#123; UserDao userDao = new UserDao(); System.out.println("我是在configuration中的"+userDao); return userDao; &#125;&#125; 测试代码：要使用@ContextConfiguration加载配置类的信息[引入test包] 12345678910111213141516171819202122package bb;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;//加载配置类的信息@ContextConfiguration(classes = Configuration.class)public class Test2 &#123; @Test public void test33() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bb/bean.xml"); UserDao userDao = (UserDao) ac.getBean("userDao"); System.out.println(userDao); &#125;&#125; 三种方式混合 注解和XML配置是可以混合使用的，JavaConfig和XML也是可以混合使用的 如果JavaConfig的配置类是分散的，我们一般再创建一个更高级的配置类（root），然后使用@Import来将配置类进行组合如果XML的配置文件是分散的，我们也是创建一个更高级的配置文件（root），然后使用来将配置文件组合 在JavaConfig引用XML 使用@ImportResource() 在XML引用JavaConfig 使用节点就行了 bean对象创建细节 scope属性 指定scope属性，IOC容器就知道创建对象的时候是单例还是多例的了 ​ 属性的值就只有两个：单例(singleton)/多例(prototype) 当我们使用singleton的时候, 从IOC容器获取的对象都是同一个 当我们使用prototype的时候, 从IOC容器获取的对象都是不同的 scope属性除了控制对象是单例还是多例的，还控制着对象创建的时间！ 我们在User的构造函数中打印出一句话，就知道User对象是什么时候创建了。 1234public User() &#123; System.out.println("我是User，我被创建了"); &#125; 当使用singleton的时候，对象在IOC容器之前就已经创建了 当使用prototype的时候，对象在使用的时候才创建 lazy-init属性 lazy-init属性只对singleton[单例]的对象有效…..lazy-init默认为false…. 有的时候，可能我们想要对象在使用的时候才创建，那么将lazy-init设置为ture就行了 init-method和destroy-method 如果我们想要对象在创建后, 执行某个方法, 我们指定为init-method属性就行了 如果我们想要IOC容器销毁后, 执行某个方法, 我们指定destroy-method属性就行了 1&lt;bean id="user" class="User" scope="singleton" lazy-init="true" init-method="" destroy-method=""/&gt; bean创建细节总结 /** * 1) 对象创建： 单例/多例 * scope=”singleton”, 默认值， 即 默认是单例 [service/dao/工具类] * scope=”prototype”, 多例； [Action对象] * * 2) 什么时候创建? * scope=”prototype” 在用到对象的时候，才创建对象。 * scope=”singleton” 在启动(容器初始化之前)， 就已经创建了bean，且整个应用只有一个。 * 3)是否延迟创建 * lazy-init=”false” 默认为false, 不延迟创建，即在启动时候就创建对象 * lazy-init=”true” 延迟初始化， 在用到对象的时候才创建对象 * （只对单例有效） * 4) 创建对象之后，初始化/销毁 * init-method=”init_user” [对应对象的init_user方法，在对象创建之后执行 ] * destroy-method=”destroy_user” [在调用容器对象的destroy方法时候执行，(容器用实现类)] */]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
