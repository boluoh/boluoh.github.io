{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/07/25/hello-world/"},{"title":"Spring MVC","text":"SpringMvc的基础知识 简介Spring MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架 ，是Spring系开源项目中的一个，和IoC配合使用。通过策略接口，Spring框架是高度可配置的，而且支持多种视图技术。Spring分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让他们更容易进行定制。Spring MVC解决的问题如下： 将web页面的请求传给服务器； 根据不同的请求处理不同的逻辑单元； 返回处理结果数据并跳转至响应页面； 通过下面这样图可以看到Spring MVC在Spring全家桶中的位置： MVC 设计概述早期的 MVC 模型（Model2）就像下图这样： 首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。 M 代表 模型（Model）模型是什么呢？ 模型就是数据，就是 dao,bean V 代表 视图（View）视图是什么呢？ 就是网页, JSP，用来展示模型中的数据 C 代表 控制器（controller)控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。 Spring MVC 的架构为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案： 传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。 特点： 结构松散，几乎可以在 Spring MVC 中使用各类视图 松耦合，各个模块分离 与 Spring 无缝集成 Spring MVC实例 新建maven web项目, 除了SpringMVC还需要添加javax.servlet的包 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.18.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0-b01&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 在web.xml中需要添加使用的servlet和映射规则 123456789101112&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!-- 匹配所有 --&gt; &lt;/servlet-mapping&gt; 新建dispatcher-servlet.xml文件, 这个文件名的开头 dispatcher 与上面 web.xml 中的 &lt;servlet-name&gt; 元素配置的 dispatcher 对应，这是 Spring MVC 的映射配置文件（xxx-servlet.xml）, 这里面负责配置映射类和视图适配器等 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类（不写会导致404问题） --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 下面是配置扫描包的位置,包名为com.learnspringmvc,也就是说我们的视图解析器应该放在com.learnspringmvc包下 --&gt; &lt;context:component-scan base-package=\"com.learnspringmvc\" /&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 前缀,我们的视图文件应该放到/WEB-INF/jsp/目录下,这里我们需要在WEB-INF下面创建jsp文件夹 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 设置后缀为.jsp --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 在WEB-INF下新建jsp文件夹，然后在jsp下新建demo.jsp 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello springMVC!&lt;/body&gt;&lt;/html&gt; 在main文件夹下新建java文件夹，在新建HelloController.java文件，包名为com.learnspringmvc.controllers 123456789101112131415161718package com.learnspringmvc.controllers;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;//控制器注解@Controller@RequestMapping(\"/hello\")public class HelloController { @RequestMapping(\"/showdemo\") public String getString() { // 必须在配置的view路径下存在demo.jsp,否则返回404 return \"demo\"; }} @Controller 注解： 很明显，这个注解是用来声明控制器的，但实际上这个注解对 Spring MVC 本身的影响并不大。（Spring 实战说它仅仅是辅助实现组件扫描，可以用 @Component 注解代替) @RequestMapping 注解： 很显然，这就表示路径 /….. 会映射到该方法上, 上例访问地址为: localhost/hello/showdemo 控制器接收请求数据使用控制器接收参数往往是 Spring MVC 开发业务逻辑的第一步，为探索 Spring MVC 的传参方式，为此我们先来创建一个简单的表单用于提交数据： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.*\" isELIgnored=\"false\"%&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Spring MVC 传参方式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/param\" role=\"form\"&gt; 用户名：&lt;input type=\"text\" name=\"userName\"&gt;&lt;br/&gt; 密码：&lt;input type=\"text\" name=\"password\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提 交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 使用servlet原生api实现 12345678910@RequestMapping(\"/param\")public ModelAndView getParam(HttpServletRequest request, HttpServletResponse response) { String userName = request.getParameter(\"userName\"); String password = request.getParameter(\"password\"); System.out.println(userName); System.out.println(password); return null;} 使用同名匹配规则 1234567@RequestMapping(\"/param\")public ModelAndView getParam(String userName, String password) { System.out.println(userName); System.out.println(password); return null;} 问题： 这样又会和前台产生很强的耦合，这是我们不希望的 解决： 使用 @RequestParam(&quot;前台参数名&quot;) 来注入： 1234567@RequestMapping(\"/param\")public ModelAndView getParam(@RequestParam(\"username\") String userName, String password) { System.out.println(userName); System.out.println(password); return null;} @RequestParam 注解细节： 该注解有三个变量：value、required、defaultvalue value ：指定 name 属性的名称是什么，value 属性都可以默认不写 required ：是否必须要有该参数，可以设置为 true 或者 false defaultvalue ：设置默认值 前台参数名必须和defaultvalue相同 中文乱码问题注意： 跟 Servlet 中的一样，该方法只对 POST 方法有效（因为是直接处理的 request） 我们可以通过配置 Spring MVC 字符编码过滤器来完成，在 web.xml 中添加： 12345678910111213&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;!-- 设置编码格式 --&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 控制器回显数据 创建一个test.jsp 1234567891011&lt;!DOCTYPE html&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.*\" isELIgnored=\"false\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Spring MVC 数据回显&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;回显数据：${message}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 使用springmvc提供的ModelAndView 1234567@RequestMapping(\"/value\")public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) { ModelAndView mav = new ModelAndView(\"test\"); mav.addObject(\"message\", \"成功!\"); return mav;} 使用Model对象 在 Spring MVC 中，我们通常都是使用这样的方式来绑定数据 12345@RequestMapping(\"/value\")public String handleRequest(Model model) { model.addAttribute(\"message\", \"成功!\"); return \"test\";} ​ 使用 @ModelAttribute 注解 123456789@ModelAttributepublic void model(Model model) { model.addAttribute(\"message\", \"注解成功\");}@RequestMapping(\"/value\")public String handleRequest() { return \"test\";} 这样写就会在访问控制器方法 handleRequest() 时，会首先调用 model() 方法将 message 添加进页面参数中去，在视图中可以直接调用，但是这样写会导致该控制器所有的方法都会首先调用 model() 方法，但同样的也很方便，因为可以加入各种各样的数据。 客户端跳转前面不管是地址 /hello 跳转到 index.jsp 还是 /test 跳转到 test.jsp，这些都是服务端的跳转，也就是 request.getRequestDispatcher(&quot;地址&quot;).forward(request, response); 那我们如何进行客户端跳转呢？我们继续在 HelloController 中编写： 123456789101112@RequestMapping(\"/hello\")public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { ModelAndView mav = new ModelAndView(\"index\"); mav.addObject(\"message\", \"Hello Spring MVC\"); return mav;}@RequestMapping(\"/jump\")public ModelAndView jump() { ModelAndView mav = new ModelAndView(\"redirect:/hello\"); return mav;} 我们使用 redirect:/hello 就表示我们要跳转到 /hello 这个路径，我们重启服务器，在地址栏中输入：localhost/jump ，会自动跳转到 /hello 路径下： 也可以这样用： 1234@RequestMapping(\"/jump\")public String jump() { return \"redirect: ./hello\";} 文件上传注意： 需要先导入 commons-io-1.3.2.jar 和 commons-fileupload-1.2.1.jar 两个包 配置上传解析器 在 dispatcher-servlet.xml 中新增一句： 1&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"/&gt; 开启对上传功能的支持 文件名为 upload.jsp，仍创建在 jsp 下： 123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;测试文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"picture\"&gt; &lt;input type=\"submit\" value=\"上 传\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 编写控制器 12345678910111213141516171819202122package controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class UploadController { @RequestMapping(\"/upload\") public void upload(@RequestParam(\"picture\") MultipartFile picture) throws Exception { System.out.println(picture.getOriginalFilename()); } @RequestMapping(\"/test2\") public ModelAndView upload() { return new ModelAndView(\"upload\"); }}","link":"/2019/07/31/Spring-MVC/"},{"title":"java基础知识","text":"基础知识 1.1 重载和重写的区别重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。 1.2 String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的？可变性简单的来说：String 类中使用 final 关键字字符数组保存字符串， private final char value[] ，所以 String对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在AbstractStringBuilder中也是使用字符数组保存字符串 char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅码。AbstractStringBuilder.java 12345678abstract class AbstractStringBuilder implements Appendable, CharSequence { char[] value; int count; AbstractStringBuilder() { } AbstractStringBuilder(int capacity) { value = new char[capacity];} 线程安全性String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没对方法进行加同步锁，所以是非线程安全的。 性能 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象. StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。对于三者使用的总结： 操作少量的数据 = String 单线程操作字符串缓冲区下操作大量数据 = StringBuilder 多线程操作字符串缓冲区下操作大量数据 = StringBuffer 1.3 自动装箱与拆箱装箱：将基本类型用它们对应的引用类型包装起来；拆箱：将包装类型转换为基本数据类型； 1.4 == 与 equals== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。举个例子： 1234567891011121314151617public class test1 {public static void main(String[] args) { String a = new String(\"ab\"); // a 为一个引用 String b = new String(\"ab\"); // b为另一个引用,对象的内容一样 String aa = \"ab\"; // 放在常量池中 String bb = \"ab\"; // 从常量池中查找 if (aa == bb) // true System.out.println(\"aa==bb\"); if (a == b) // false，非同一对象 System.out.println(\"a==b\"); if (a.equals(b)) // true System.out.println(\"aEQb\"); if (42 == 42.0) { // true System.out.println(\"true\"); } }} 说明： String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 1.5 关于 final 关键字的一些总结final关键字主要用在三个地方：变量、方法、类。 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为fianl。 1.6 Object类的常见方法总结Object类是一个特殊的类，是所有类的父类。它主要提供了以下11个方法： 123456789101112131415161718192021public final native Class&lt;?&gt; getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。 public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。 public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。 protected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass()==x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。 public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。public final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念protected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作 1.7 Java 中的异常处理Java异常类层次结构图 在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 Throwable类。Throwable： 有两个重要的子类：Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。 Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError）, 当JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。 这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（VirtualMachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。 Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由Java虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）和ArrayIndexOutOfBoundsException （下标越界异常）。 注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。 Throwable类常用方法 public string getMessage():返回异常发生时的详细信息 public string toString():返回异常发生时的简要描述 public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同 public void printStackTrace():在控制台上打印Throwable对象封装的异常信息 异常处理总结 try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。 catch 块：用于处理try捕获到的异常。 finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。 在以下4种特殊情况下，finally块不会被执行： 在finally语句块中发生了异常。 在前面的代码中用了System.exit()退出程序。 程序所在的线程死亡。 关闭CPU。 1.8 获取用键盘输入常用的的两种方法方法1：通过 Scanner 123Scanner input = new Scanner(System.in);String s = input.nextLine();input.close(); 方法2：通过 BufferedReader 12BufferedReader input = new BufferedReader(new InputStreamReader(System.in));String s = input.readLine(); 1.9 接口和抽象类的区别是什么 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法 接口中的实例变量默认是 final 类型的，而抽象类中则不一定 一个类可以实现多个接口，但最多只能实现一个抽象类 一个类实现接口的话要实现接口的所有方法，而抽象类不一定 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 备注:在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，必须重写，不然会报错。(详见issue:https://github.com/Snailclimb/JavaGuide/issues/146)","link":"/2019/08/11/java基础知识/"},{"title":"Spring入门","text":"Spring的一些概念和基础知识 Spring介绍Spring诞生: 创建Spring的目的就是用来代替更加重量级的企业级java技术 简化java的开发 基于POJO轻量级和最小侵入式开发 通过依赖注入和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和模板减少板式代码 侵入式概念Spring是一种非侵入式的框架 侵入式 对于EJB, Struts2等一些传统的框架, 通常是要实现特定的接口, 继承特定的类才能增强功能 改变了java类的结构 非侵入式 对于Hibernate, Spring等框架, 对现有的类结构没有影响, 就能够增强JavaBean的功能 松耦合前面我们在写程序的时候, 都是面向接口编程, 通过DaoFactory等方法来实现松耦合 1234567private CategoryDao categoryDao = DaoFactory.getInstance().createDao(\"zhongfucheng.dao.impl.CategoryDAOImpl\", CategoryDao.class); private BookDao bookDao = DaoFactory.getInstance().createDao(\"zhongfucheng.dao.impl.BookDaoImpl\", BookDao.class); private UserDao userDao = DaoFactory.getInstance().createDao(\"zhongfucheng.dao.impl.UserDaoImpl\", UserDao.class); private OrderDao orderDao = DaoFactory.getInstance().createDao(\"zhongfucheng.dao.impl.OrderDaoImpl\", OrderDao.class); DAO层和Service层通过DaoFactory来实现松耦合 如果Service层直接new DaoBook(), 那么DAO和Service就紧耦合了[Service层依赖于Dao] 而Spring给我们更加合适的方法来实现松耦合, 并且更加灵活, 功能更加强大! —&gt;IOC控制反转 切面编程切面编程也就是AOP编程, 其实我们在之前也接触过…动态代理就是一种切面编程了… 当时我们使用动态代理+注解的方式给Service层的方法添加权限 12345678910111213141516171819202122@Override @permission(\"添加分类\") /*添加分类*/ public void addCategory(Category category) { categoryDao.addCategory(category); } /*查找分类*/ @Override public void findCategory(String id) { categoryDao.findCategory(id); } @Override @permission(\"查找分类\") /*查看分类*/ public List&lt;Category&gt; getAllCategory() { return categoryDao.getAllCategory(); } /*添加图书*/ @Override public void addBook(Book book) { bookDao.addBook(book); } Controller调用Service的时候, Service返回的是一个代理对象 代理对象得到Controller想要调用的方法, 通过反射来看看该方法上有没有注解 如果有注解的话, 那么就判断该用户是否有权限来调用此方法, 如果没有权限, 就抛出异常给Controller, Controller接收到异常, 就可以提示用户没有权限了. AOP编程可以简单理解成: 在执行某些代码前, 执行另外的代码 Struts2的拦截器也是面向切面编程[在执行Action业务方法之前执行拦截器] Spring也为我们提供更好的方法来实现面向切面编程 引出Spring在没学Spring的时候, 开发Web项目: 实体类 - - &gt; class User{} daoclass - - &gt; UserDao{ 访问数据库 } service - - &gt; class UserService{ UserDao userDao = new UserDao(); } actionclass UserAction{ UserService userService = new UserService(); } 用户访问: Tomcat -&gt; action -&gt; service -&gt; dao 有几个问题: :对象创建能否写死 :对象创建细节 action 访问时候创建 service 启动时候创建 dao 启动时候创建 action 多个 [维护成员变量] service 一个 [不需要维护公共变量] dao 一个 [不需要维护公共变量 对象数量 创建时间 :对象的依赖关系 action依赖service service依赖dao 对于第一个问题和第三个问题, 可以通过DaoFactory解决. 对于第二个问题, 我们要控制对象的数量和创建时间就有点麻烦了 而Spring框架通过IOC就很好的解决上面的问题 IOC控制反转Spring的核心思想之一: Inversion of Control, 控制反转 IOC 对象的创建交给外部容器完成, 就是控制反转 Spring使用控制反转来实现对象不用在程序中写死 控制反转解决对象处理问题[把对象交给别人创建] 那么对象和对象之间的依赖关系Spring是怎么做的呢? 依赖注入, dependency injection Spring使用依赖注入来实现对象之间的依赖关系 在创建完对象之后, 对象的关系处理就是依赖注入 控制反转是通过外部容器完成的, 而Spring又为我们提供了这么一个容器, 我们一般将这个容器叫做: IOC容器. 无论是创建对象, 处理对象之间的依赖关系, 对象创建的时间还是对象的数量, 我们都是在Spring为我们提供的IOC容器上配置对象的信息就好了. 那么使用IOC控制反转这一思想有什么作用呢? 来自知乎 我摘取一下核心的部分： ioc的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。 也就是说，甲方要达成某种目的不需要直接依赖乙方，它只需要达到的目的告诉第三方机构就可以了，比如甲方需要一双袜子，而乙方它卖一双袜子，它要把袜子卖出去，并不需要自己去直接找到一个卖家来完成袜子的卖出。它也只需要找第三方，告诉别人我要卖一双袜子。这下好了，甲乙双方进行交易活动，都不需要自己直接去找卖家，相当于程序内部开放接口，卖家由第三方作为参数传入。甲乙互相不依赖，而且只有在进行交易活动的时候，甲才和乙产生联系。反之亦然。这样做什么好处么呢，甲乙可以在对方不真实存在的情况下独立存在，而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。那么交易就能很可靠很灵活的产生和进行了。这就是ioc的核心思想。生活中这种例子比比皆是，支付宝在整个淘宝体系里就是庞大的ioc容器，交易双方之外的第三方，提供可靠性可依赖可灵活变更交易方的资源管理中心。另外人事代理也是，雇佣机构和个人之外的第三方。==========================update=========================== 在以上的描述中，诞生了两个专业词汇，依赖注入和控制反转所谓的依赖注入，则是，甲方开放接口，在它需要的时候，能够讲乙方传递进来(注入)所谓的控制反转，甲乙双方不相互依赖，交易活动的进行不依赖于甲乙任何一方，整个活动的进行由第三方负责管理。 Spring模块Spring可以分为6大模块 Spring Core Spring的核心功能: IOC容器, 解决对象创建及依赖关系 Spring Web Spring对web模块的支持 可以与Struts整合, 让Struts的action创建交给spring spring mvc模式 Spring DAO Spring对jdbc操作的支持 Spring ORM spring对orm的支持: 既可以与hibernate整合,[session] 也可以使用spring的对hibernate操作的封装 Spring AOP 切面编程 SpringEE Spring对javaEE其他模块的支持 Core模块快速入门搭建配置环境引入jar包: 涉及到Spring core的开发jar包有五个: commons-logging-1.1.3.jar 日志 spring-beans-3.2.5.RELEASE.jar bean节点 spring-context-3.2.5.RELEASE.jar spring上下文节点 spring-core-3.2.5.RELEASE.jar spring核心功能 spring-expression-3.2.5.RELEASE.jar spring表达式相关表 编写配置文件: Spring核心的配置文件applicationContext.xml或者叫bean.xml 那这个配置文件怎么写呢？？一般地，我们都知道框架的配置文件都是有约束的…我们可以在spring-framework-3.2.5.RELEASE\\docs\\spring-framework-reference\\htmlsingle\\index.html找到XML配置文件的约束 1234567891011&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; 前面在介绍Spring模块的时候已经说了，Core模块是：IOC容器，解决对象创建和之间的依赖关系。 因此Core模块主要是学习如何得到IOC容器，通过IOC容器来创建对象、解决对象之间的依赖关系、IOC细节。 得到Spring容器对象[IOC]容器 Bean工厂，BeanFactory[功能简单] 应用上下文，ApplicationContext[功能强大，一般我们使用这个] 加载配置文件 通过XmlBeanFactory+配置文件来创建IOC容器 12345//加载Spring的资源文件Resource resource = new ClassPathResource(\"applicationContext.xml\");//创建IOC容器对象【IOC容器=工厂类+applicationContext.xml】BeanFactory beanFactory = new XmlBeanFactory(resource); 直接通过ClassPathXmlApplicationContext对象来获取 12// 得到IOC容器对象ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 在Spring中总体来看可以通过三种方式来配置对象: 使用XML文件配置 使用注解来配置 使用JavaConfig来配置 XML配置方式在上面我们已经可以得到IOC对象了. 接下来就是在applicationContext.xml文件中配置信息[让IOC容器根据applicationContext.xml文件来创建对象] 首先我们有个JavaBean的类 12345678910111213141516171819202122public class User { private String id; private String username; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; }} 以前我们是通过new User的方法创建对象的 1User user = new User; 现在我们有了IOC容器, 可以让IOC容器帮我们创建对象了. 在applicationContext.xml文件中配置对应的信息就行了 123456&lt;!-- 使用bean节点来创建对象 id属性标识着对象 name属性代表着要创建对象的类全名 --&gt;&lt;bean id=\"user\" class=\"User\"/&gt; 通过IOC容器对象获取对象 在外界通过IOC容器对象得到User对象 1User user = (User) ac.getBean(\"user\"); 上面我们使用的是IOC通过无参构造函数来创建对象, 我们来回顾一下一般有几种创建对象的方式： 无参构造函数创建对象 带参数的构造函数创建对象 工厂创建对象 静态方法创建对象 非静态方法创建对象 使用无参的构造函数创建对象我们已经会了, 接下来我们看看使用剩下的IOC容器是怎么创建对象的. 带参数的构造函数创建对象 首先, JavaBean要提供带参数的构造函数 1234public User(String id, String username) { this.id = id; this.username = username; } 接下来, 关键是怎么配置xml文件 12345&lt;bean id=\"user\" class=\"User\"&gt; &lt;!--通过constructor这个节点来指定构造函数的参数类型、名称、第几个--&gt; &lt;constructor-arg index=\"0\" name=\"id\" type=\"java.lang.String\" value=\"1\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=\"1\" name=\"username\" type=\"java.lang.String\" value=\"zhongfucheng\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 在constructor上如果构造函数的值是一个对象，而不是一个普通类型的值，我们就需要用到ref属性了，而不是value属性 比如说：我在User对象上维护了Person对象的值，想要在构造函数中初始化它。因此，就需要用到ref属性了 1234567&lt;bean id=\"person\" class=\"Person\"&gt;&lt;/bean&gt; &lt;bean id=\"user\" class=\"User\" &gt; &lt;!--通过constructor这个节点来指定构造函数的参数类型、名称、第几个--&gt; &lt;constructor-arg index=\"0\" name=\"id\" type=\"java.lang.String\" value=\"1\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=\"1\" name=\"username\" type=\"java.lang.String\" ref=\"person\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 工厂静态方法创建对象 首先, 使用一个工厂的静态方法返回一个对象 123456public class Factory { public static User getBean() { return new User(); }} 配置文件中使用工厂的静态方法返回对象 1234&lt;!--工厂静态方法创建对象，直接使用class指向静态类，指定静态方法就行了--&gt; &lt;bean id=\"user\" class=\"Factory\" factory-method=\"getBean\" &gt; &lt;/bean&gt; 工厂非静态方法创建对象 首先, 也是通过工厂的非非静态方法来得到一个对象 123456public class Factory { public User getBean() { return new User(); }} 配置文件中使用工厂的非静态方法返回对象 12345&lt;!--首先创建工厂对象--&gt; &lt;bean id=\"factory\" class=\"Factory\"/&gt; &lt;!--指定工厂对象和工厂方法--&gt; &lt;bean id=\"user\" class=\"User\" factory-bean=\"factory\" factory-method=\"getBean\"/&gt; 装载集合 如果对象上的属性或者构造函数拥有集合的时候, 而我们又需要为集合赋值, 那么怎么办？ 在构造函数上，普通类型 12345678 &lt;bean id=\"userService\" class=\"bb.UserService\" &gt; &lt;constructor-arg &gt; &lt;list&gt; //普通类型 &lt;value&gt;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; 在属性上,引用类型 123456&lt;property name=\"userDao\"&gt; &lt;list&gt; &lt;ref&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; 注解方式通过注解来配置信息就是为了简化IOC容器的配置, 注解可以把对象添加到IOC容器中, 处理对象依赖关系, 我们来看看怎么用吧： 使用注解步骤： 1. 先引入context名称空间 xmlns:context=”http://www.springframework.org/schema/context&quot; 2. 开启注解扫描器 &lt;context:component-scan base-package=&quot;&quot;&gt;&lt;/context:component-scan&gt; 第二种方法:也可以通过自定义扫描类以@CompoentScan修饰来扫描IOC容器的bean对象。。如下代码: 12345678910//表明该类是配置类@Configuration//启动扫描器，扫描bb包下的 //也可以指定多个基础包 //也可以指定类型@ComponentScan(\"bb\")public class AnnotationScan {} 在使用@ComponentScan()这个注解的时候，在测试类上需要@ContextConfiguration这个注解来加载配置类 @ContextConfiguration这个注解又在Spring的test包下 创建对象以及处理对象依赖关系，相关的注解： @ComponentScan扫描器 @Configuration表明该类是配置类 @Component 指定把一个对象加入IOC容器—&gt;@Name也可以实现相同的效果【一般少用】 @Repository 作用同@Component； 在持久层使用 @Service 作用同@Component； 在业务逻辑层使用 @Controller 作用同@Component； 在控制层使用 @Resource 依赖关系 如果@Resource不指定值，那么就根据类型来找，相同的类型在IOC容器中不能有两个 如果@Resource指定了值，那么就根据名字来找 测试代码: UserDao 12345678package aa;import org.springframework.stereotype.Repository;//把对象添加到容器中,首字母会小写@Repositorypublic class UserDao { public void save() { System.out.println(\"DB:保存用户\"); }} userService 1234567891011121314151617181920212223package aa;import org.springframework.stereotype.Service;import javax.annotation.Resource;//把UserService对象添加到IOC容器中,首字母会小写@Servicepublic class UserService { //如果@Resource不指定值，那么就根据类型来找---&gt;UserDao....当然了，IOC容器不能有两个UserDao类型的对象 //@Resource //如果指定了值，那么Spring就在IOC容器找有没有id为userDao的对象。 @Resource(name = \"userDao\") private UserDao userDao; public void save() { userDao.save(); }} useraction 123456789101112131415161718package aa;import org.springframework.stereotype.Controller;import javax.annotation.Resource;//把对象添加到IOC容器中,首字母会小写@Controllerpublic class UserAction { @Resource(name = \"userService\") private UserService userService; public String execute() { userService.save(); return null; }} 测试 1234567891011121314151617package aa;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App { public static void main(String[] args) { // 创建容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"aa/applicationContext.xml\"); UserAction userAction = (UserAction) ac.getBean(\"userAction\"); userAction.execute(); }} 通过java方式由于Spring的自动装配并不能将第三方库组件装配到应用中, 于是需要显式装配配置. 显示装配有两种方式 通过java代码装配bean 通过XML装配bean Spring In Action作者首推使用自动装配的功能，而后是通过java代码配置bean，最后才用XML文件配置的方式.. 那么怎么通过java代码来配置Bean呢？？ 编写一个java类，使用@Configuration修饰该类 被@Configuration修饰的类就是配置类 编写配置类: 1234@org.springframework.context.annotation.Configuration public class Configuration { } 使用配置类创建bean: 使用@Bean来修饰方法，该方法返回一个对象 不管方法体内的对象是怎么创建的，Spring可以获取得到对象就行了 Spring内部会将该对象加入到Spring容器中 容器中bean的ID默认为方法名 123456789101112@org.springframework.context.annotation.Configurationpublic class Configuration { @Bean public UserDao userDao() { UserDao userDao = new UserDao(); System.out.println(\"我是在configuration中的\"+userDao); return userDao; }} 测试代码：要使用@ContextConfiguration加载配置类的信息[引入test包] 12345678910111213141516171819202122package bb;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;//加载配置类的信息@ContextConfiguration(classes = Configuration.class)public class Test2 { @Test public void test33() { ApplicationContext ac = new ClassPathXmlApplicationContext(\"bb/bean.xml\"); UserDao userDao = (UserDao) ac.getBean(\"userDao\"); System.out.println(userDao); }} 三种方式混合注解和XML配置是可以混合使用的，JavaConfig和XML也是可以混合使用的 如果JavaConfig的配置类是分散的，我们一般再创建一个更高级的配置类（root），然后使用@Import来将配置类进行组合如果XML的配置文件是分散的，我们也是创建一个更高级的配置文件（root），然后使用来将配置文件组合 在JavaConfig引用XML 使用@ImportResource() 在XML引用JavaConfig 使用节点就行了 bean对象创建细节 scope属性 指定scope属性，IOC容器就知道创建对象的时候是单例还是多例的了 ​ 属性的值就只有两个：单例(singleton)/多例(prototype) 当我们使用singleton的时候, 从IOC容器获取的对象都是同一个 当我们使用prototype的时候, 从IOC容器获取的对象都是不同的 scope属性除了控制对象是单例还是多例的，还控制着对象创建的时间！ 我们在User的构造函数中打印出一句话，就知道User对象是什么时候创建了。 1234public User() { System.out.println(\"我是User，我被创建了\"); } 当使用singleton的时候，对象在IOC容器之前就已经创建了 当使用prototype的时候，对象在使用的时候才创建 lazy-init属性 lazy-init属性只对singleton[单例]的对象有效…..lazy-init默认为false…. 有的时候，可能我们想要对象在使用的时候才创建，那么将lazy-init设置为ture就行了 init-method和destroy-method 如果我们想要对象在创建后, 执行某个方法, 我们指定为init-method属性就行了 如果我们想要IOC容器销毁后, 执行某个方法, 我们指定destroy-method属性就行了 1&lt;bean id=\"user\" class=\"User\" scope=\"singleton\" lazy-init=\"true\" init-method=\"\" destroy-method=\"\"/&gt; bean创建细节总结 /** * 1) 对象创建： 单例/多例 * scope=”singleton”, 默认值， 即 默认是单例 [service/dao/工具类] * scope=”prototype”, 多例； [Action对象] * * 2) 什么时候创建? * scope=”prototype” 在用到对象的时候，才创建对象。 * scope=”singleton” 在启动(容器初始化之前)， 就已经创建了bean，且整个应用只有一个。 * 3)是否延迟创建 * lazy-init=”false” 默认为false, 不延迟创建，即在启动时候就创建对象 * lazy-init=”true” 延迟初始化， 在用到对象的时候才创建对象 * （只对单例有效） * 4) 创建对象之后，初始化/销毁 * init-method=”init_user” [对应对象的init_user方法，在对象创建之后执行 ] * destroy-method=”destroy_user” [在调用容器对象的destroy方法时候执行，(容器用实现类)] */","link":"/2019/07/30/Spring/"},{"title":"java集合框架","text":"List,Map 1.1 Arraylist 与 LinkedList 异同 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全； 底层数据结构： Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向链表数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别：）； 插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行 add(E e) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（ add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于 get(int index) 方法)。 内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。 补充内容:RandomAccess接口 12public interface RandomAccess {} 查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。 在binarySearch（）方法中，它要判断传入的list 是否RamdomAccess的实例，如果是，调用indexedBinarySearch（）方法，如果不是，那么调用iteratorBinarySearch（）方法 1234567public static &lt;T&gt;int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) { if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key);} ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。，ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的! 下面再总结一下 list 的遍历方式选择： 实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach 未实现RandomAccess接口的list， 优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大size的数据，千万不要使用普通for循环 补充：数据结构基础之双向链表双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。 1.2 ArrayList 与 Vector 区别Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。 1.3 HashMap的底层实现JDK1.8之前JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。 所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。 JDK 1.8 HashMap 的 hash 方法源码:JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变. 1234567static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 对比一下 JDK1.7的 HashMap 的 hash 方法源码. 1234567static int hash(int h) { // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);} 相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可 JDK1.8之后相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间. TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。 1.4 HashMap 和 Hashtable 的区别 线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）； 效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它； 对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出NullPointerException。 初始容量大小和每次扩充容量大小的不同 ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的 tableSizeFor() 方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。 底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。 HasMap 中带有初始容量的构造函数： 123456789101112131415public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);} public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR);} 下面这个方法保证了 HashMap 总是使用2的幂作为哈希表的大小。 123456789101112/*** Returns a power of two size for the given target capacity.*/static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;} 1.5 HashMap 的长度为什么是2的幂次方为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) &amp; hash ”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。 这个算法应该如何设计呢？ 我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。 1.6 HashMap 多线程操作导致死循环问题在多线程下，进行 put 操作会导致 HashMap 死循环，原因在于 HashMap 的扩容 resize()方法。由于扩容是新建一个数组，复制原数据到数组。由于数组下标挂有链表，所以需要复制链表，但是多线程操作有可能导致环形链表。复制链表过程如下:以下模拟2个线程同时扩容。假设，当前 HashMap 的空间为2（临界值为1），hashcode 分别为 0 和 1，在散列地址 0 处有元素 A 和 B，这时候要添加元素 C，C 经过 hash 运算，得到散列地址为 1，这时候由于超过了临界值，空间不够，需要调用 resize 方法进行扩容，那么在多线程条件下，会出现条件竞争，模拟过程如下： 线程一：读取到当前的 HashMap 情况，在准备扩容时，线程二介入 线程二：读取 HashMap，进行扩容 线程一：继续执行 这个过程为，先将 A 复制到新的 hash 表中，然后接着复制 B 到链头（A 的前边：B.next=A），本来 B.next=null，到此也就结束了（跟线程二一样的过程），但是，由于线程二扩容的原因，将 B.next=A，所以，这里继续复制A，让A.next=B，由此，环形链表出现：B.next=A; A.next=B 注意：jdk1.8已经解决了死循环的问题。 1.7 HashSet 和 HashMap 区别如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone() 方法、writeObject()方法、readObject()方法是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。） 1.8 ConcurrentHashMap 和 Hashtable 的区别ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。 底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的； 实现线程安全的方式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。 HashTable: JDK1.7的ConcurrentHashMap： JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）： 1.9 ConcurrentHashMap线程安全的具体实现方式/底层具体实现JDK1.7（上面有示意图）首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。 ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。 12static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {} 一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁. JDK1.8 （上面有示意图）ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。 2.10 集合框架底层数据结构总结Collection List Arraylist： Object数组 Vector： Object数组 LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环) Set HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素 LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。 TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。) Map HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间 LinkedHashMap: LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。 HashTable: 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的 TreeMap: 红黑树（自平衡的排序二叉树）","link":"/2019/08/11/java集合框架/"}],"tags":[{"name":"springmvc","slug":"springmvc","link":"/tags/springmvc/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"spring","slug":"spring","link":"/tags/spring/"}],"categories":[{"name":"javaweb","slug":"javaweb","link":"/categories/javaweb/"},{"name":"面试","slug":"面试","link":"/categories/面试/"}]}