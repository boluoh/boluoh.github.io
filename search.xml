<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring MVC]]></title>
    <url>%2F2019%2F07%2F31%2FSpring-MVC%2F</url>
    <content type="text"><![CDATA[简介Spring MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架 ，是Spring系开源项目中的一个，和IoC配合使用。通过策略接口，Spring框架是高度可配置的，而且支持多种视图技术。Spring分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让他们更容易进行定制。Spring MVC解决的问题如下： 将web页面的请求传给服务器； 根据不同的请求处理不同的逻辑单元； 返回处理结果数据并跳转至响应页面； 通过下面这样图可以看到Spring MVC在Spring全家桶中的位置： MVC 设计概述早期的 MVC 模型（Model2）就像下图这样： 首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。 M 代表 模型（Model）模型是什么呢？ 模型就是数据，就是 dao,bean V 代表 视图（View）视图是什么呢？ 就是网页, JSP，用来展示模型中的数据 C 代表 控制器（controller)控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。 Spring MVC 的架构为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案： 传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。 特点： 结构松散，几乎可以在 Spring MVC 中使用各类视图 松耦合，各个模块分离 与 Spring 无缝集成 Spring MVC实例 新建maven web项目, 除了SpringMVC还需要添加javax.servlet的包 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.18.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0-b01&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 在web.xml中需要添加使用的servlet和映射规则 123456789101112&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!-- 匹配所有 --&gt; &lt;/servlet-mapping&gt; 新建dispatcher-servlet.xml文件, 这个文件名的开头 dispatcher 与上面 web.xml 中的 &lt;servlet-name&gt; 元素配置的 dispatcher 对应，这是 Spring MVC 的映射配置文件（xxx-servlet.xml）, 这里面负责配置映射类和视图适配器等 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类（不写会导致404问题） --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 下面是配置扫描包的位置,包名为com.learnspringmvc,也就是说我们的视图解析器应该放在com.learnspringmvc包下 --&gt; &lt;context:component-scan base-package="com.learnspringmvc" /&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 前缀,我们的视图文件应该放到/WEB-INF/jsp/目录下,这里我们需要在WEB-INF下面创建jsp文件夹 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 设置后缀为.jsp --&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; 在WEB-INF下新建jsp文件夹，然后在jsp下新建demo.jsp 123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello springMVC!&lt;/body&gt;&lt;/html&gt; 在main文件夹下新建java文件夹，在新建HelloController.java文件，包名为com.learnspringmvc.controllers 123456789101112131415161718package com.learnspringmvc.controllers;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;//控制器注解@Controller@RequestMapping("/hello")public class HelloController &#123; @RequestMapping("/showdemo") public String getString() &#123; // 必须在配置的view路径下存在demo.jsp,否则返回404 return "demo"; &#125;&#125; @Controller 注解： 很明显，这个注解是用来声明控制器的，但实际上这个注解对 Spring MVC 本身的影响并不大。（Spring 实战说它仅仅是辅助实现组件扫描，可以用 @Component 注解代替) @RequestMapping 注解： 很显然，这就表示路径 /….. 会映射到该方法上, 上例访问地址为: localhost/hello/showdemo 控制器接收请求数据使用控制器接收参数往往是 Spring MVC 开发业务逻辑的第一步，为探索 Spring MVC 的传参方式，为此我们先来创建一个简单的表单用于提交数据： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" import="java.util.*" isELIgnored="false"%&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Spring MVC 传参方式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="/param" role="form"&gt; 用户名：&lt;input type="text" name="userName"&gt;&lt;br/&gt; 密码：&lt;input type="text" name="password"&gt;&lt;br/&gt; &lt;input type="submit" value="提 交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 使用servlet原生api实现 12345678910@RequestMapping("/param")public ModelAndView getParam(HttpServletRequest request, HttpServletResponse response) &#123; String userName = request.getParameter("userName"); String password = request.getParameter("password"); System.out.println(userName); System.out.println(password); return null;&#125; 使用同名匹配规则 1234567@RequestMapping("/param")public ModelAndView getParam(String userName, String password) &#123; System.out.println(userName); System.out.println(password); return null;&#125; 问题： 这样又会和前台产生很强的耦合，这是我们不希望的 解决： 使用 @RequestParam(&quot;前台参数名&quot;) 来注入： 1234567@RequestMapping("/param")public ModelAndView getParam(@RequestParam("username") String userName, String password) &#123; System.out.println(userName); System.out.println(password); return null;&#125; @RequestParam 注解细节： 该注解有三个变量：value、required、defaultvalue value ：指定 name 属性的名称是什么，value 属性都可以默认不写 required ：是否必须要有该参数，可以设置为 true 或者 false defaultvalue ：设置默认值 前台参数名必须和defaultvalue相同 中文乱码问题注意： 跟 Servlet 中的一样，该方法只对 POST 方法有效（因为是直接处理的 request） 我们可以通过配置 Spring MVC 字符编码过滤器来完成，在 web.xml 中添加： 12345678910111213&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;!-- 设置编码格式 --&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 控制器回显数据 创建一个test.jsp 1234567891011&lt;!DOCTYPE html&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" import="java.util.*" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Spring MVC 数据回显&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;回显数据：$&#123;message&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 使用springmvc提供的ModelAndView 1234567@RequestMapping("/value")public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) &#123; ModelAndView mav = new ModelAndView("test"); mav.addObject("message", "成功!"); return mav;&#125; 使用Model对象 在 Spring MVC 中，我们通常都是使用这样的方式来绑定数据 12345@RequestMapping("/value")public String handleRequest(Model model) &#123; model.addAttribute("message", "成功!"); return "test";&#125; ​ 使用 @ModelAttribute 注解 123456789@ModelAttributepublic void model(Model model) &#123; model.addAttribute("message", "注解成功");&#125;@RequestMapping("/value")public String handleRequest() &#123; return "test";&#125; 这样写就会在访问控制器方法 handleRequest() 时，会首先调用 model() 方法将 message 添加进页面参数中去，在视图中可以直接调用，但是这样写会导致该控制器所有的方法都会首先调用 model() 方法，但同样的也很方便，因为可以加入各种各样的数据。 客户端跳转前面不管是地址 /hello 跳转到 index.jsp 还是 /test 跳转到 test.jsp，这些都是服务端的跳转，也就是 request.getRequestDispatcher(&quot;地址&quot;).forward(request, response); 那我们如何进行客户端跳转呢？我们继续在 HelloController 中编写： 123456789101112@RequestMapping("/hello")public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mav = new ModelAndView("index"); mav.addObject("message", "Hello Spring MVC"); return mav;&#125;@RequestMapping("/jump")public ModelAndView jump() &#123; ModelAndView mav = new ModelAndView("redirect:/hello"); return mav;&#125; 我们使用 redirect:/hello 就表示我们要跳转到 /hello 这个路径，我们重启服务器，在地址栏中输入：localhost/jump ，会自动跳转到 /hello 路径下： 也可以这样用： 1234@RequestMapping("/jump")public String jump() &#123; return "redirect: ./hello";&#125; 文件上传注意： 需要先导入 commons-io-1.3.2.jar 和 commons-fileupload-1.2.1.jar 两个包 配置上传解析器 在 dispatcher-servlet.xml 中新增一句： 1&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/&gt; 开启对上传功能的支持 文件名为 upload.jsp，仍创建在 jsp 下： 123456789101112&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;测试文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="/upload" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="picture"&gt; &lt;input type="submit" value="上 传"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 编写控制器 12345678910111213141516171819202122package controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class UploadController &#123; @RequestMapping("/upload") public void upload(@RequestParam("picture") MultipartFile picture) throws Exception &#123; System.out.println(picture.getOriginalFilename()); &#125; @RequestMapping("/test2") public ModelAndView upload() &#123; return new ModelAndView("upload"); &#125;&#125;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring入门]]></title>
    <url>%2F2019%2F07%2F30%2FSpring%2F</url>
    <content type="text"><![CDATA[Spring介绍 Spring诞生: 创建Spring的目的就是用来代替更加重量级的企业级java技术 简化java的开发 基于POJO轻量级和最小侵入式开发 通过依赖注入和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和模板减少板式代码 侵入式概念 Spring是一种非侵入式的框架 侵入式 对于EJB, Struts2等一些传统的框架, 通常是要实现特定的接口, 继承特定的类才能增强功能 改变了java类的结构 非侵入式 对于Hibernate, Spring等框架, 对现有的类结构没有影响, 就能够增强JavaBean的功能 松耦合 前面我们在写程序的时候, 都是面向接口编程, 通过DaoFactory等方法来实现松耦合 1234567private CategoryDao categoryDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.CategoryDAOImpl", CategoryDao.class); private BookDao bookDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.BookDaoImpl", BookDao.class); private UserDao userDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.UserDaoImpl", UserDao.class); private OrderDao orderDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.OrderDaoImpl", OrderDao.class); DAO层和Service层通过DaoFactory来实现松耦合 如果Service层直接new DaoBook(), 那么DAO和Service就紧耦合了[Service层依赖于Dao] 而Spring给我们更加合适的方法来实现松耦合, 并且更加灵活, 功能更加强大! —&gt;IOC控制反转 切面编程 切面编程也就是AOP编程, 其实我们在之前也接触过…动态代理就是一种切面编程了… 当时我们使用动态代理+注解的方式给Service层的方法添加权限 12345678910111213141516171819202122@Override @permission("添加分类") /*添加分类*/ public void addCategory(Category category) &#123; categoryDao.addCategory(category); &#125; /*查找分类*/ @Override public void findCategory(String id) &#123; categoryDao.findCategory(id); &#125; @Override @permission("查找分类") /*查看分类*/ public List&lt;Category&gt; getAllCategory() &#123; return categoryDao.getAllCategory(); &#125; /*添加图书*/ @Override public void addBook(Book book) &#123; bookDao.addBook(book); &#125; Controller调用Service的时候, Service返回的是一个代理对象 代理对象得到Controller想要调用的方法, 通过反射来看看该方法上有没有注解 如果有注解的话, 那么就判断该用户是否有权限来调用此方法, 如果没有权限, 就抛出异常给Controller, Controller接收到异常, 就可以提示用户没有权限了. AOP编程可以简单理解成: 在执行某些代码前, 执行另外的代码 Struts2的拦截器也是面向切面编程[在执行Action业务方法之前执行拦截器] Spring也为我们提供更好的方法来实现面向切面编程 引出Spring 在没学Spring的时候, 开发Web项目: 实体类 - - &gt; class User{} daoclass - - &gt; UserDao{ 访问数据库 } service - - &gt; class UserService{ UserDao userDao = new UserDao(); } actionclass UserAction{ UserService userService = new UserService(); } 用户访问: Tomcat -&gt; action -&gt; service -&gt; dao 有几个问题: :对象创建能否写死 :对象创建细节 action 访问时候创建 service 启动时候创建 dao 启动时候创建 action 多个 [维护成员变量] service 一个 [不需要维护公共变量] dao 一个 [不需要维护公共变量 对象数量 创建时间 :对象的依赖关系 action依赖service service依赖dao 对于第一个问题和第三个问题, 可以通过DaoFactory解决. 对于第二个问题, 我们要控制对象的数量和创建时间就有点麻烦了 而Spring框架通过IOC就很好的解决上面的问题 IOC控制反转 Spring的核心思想之一: Inversion of Control, 控制反转 IOC 对象的创建交给外部容器完成, 就是控制反转 Spring使用控制反转来实现对象不用在程序中写死 控制反转解决对象处理问题[把对象交给别人创建] 那么对象和对象之间的依赖关系Spring是怎么做的呢? 依赖注入, dependency injection Spring使用依赖注入来实现对象之间的依赖关系 在创建完对象之后, 对象的关系处理就是依赖注入 控制反转是通过外部容器完成的, 而Spring又为我们提供了这么一个容器, 我们一般将这个容器叫做: IOC容器. 无论是创建对象, 处理对象之间的依赖关系, 对象创建的时间还是对象的数量, 我们都是在Spring为我们提供的IOC容器上配置对象的信息就好了. 那么使用IOC控制反转这一思想有什么作用呢? 来自知乎 我摘取一下核心的部分： ioc的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。 也就是说，甲方要达成某种目的不需要直接依赖乙方，它只需要达到的目的告诉第三方机构就可以了，比如甲方需要一双袜子，而乙方它卖一双袜子，它要把袜子卖出去，并不需要自己去直接找到一个卖家来完成袜子的卖出。它也只需要找第三方，告诉别人我要卖一双袜子。这下好了，甲乙双方进行交易活动，都不需要自己直接去找卖家，相当于程序内部开放接口，卖家由第三方作为参数传入。甲乙互相不依赖，而且只有在进行交易活动的时候，甲才和乙产生联系。反之亦然。这样做什么好处么呢，甲乙可以在对方不真实存在的情况下独立存在，而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。那么交易就能很可靠很灵活的产生和进行了。这就是ioc的核心思想。生活中这种例子比比皆是，支付宝在整个淘宝体系里就是庞大的ioc容器，交易双方之外的第三方，提供可靠性可依赖可灵活变更交易方的资源管理中心。另外人事代理也是，雇佣机构和个人之外的第三方。==========================update=========================== 在以上的描述中，诞生了两个专业词汇，依赖注入和控制反转所谓的依赖注入，则是，甲方开放接口，在它需要的时候，能够讲乙方传递进来(注入)所谓的控制反转，甲乙双方不相互依赖，交易活动的进行不依赖于甲乙任何一方，整个活动的进行由第三方负责管理。 Spring模块 Spring可以分为6大模块 Spring Core Spring的核心功能: IOC容器, 解决对象创建及依赖关系 Spring Web Spring对web模块的支持 可以与Struts整合, 让Struts的action创建交给spring spring mvc模式 Spring DAO Spring对jdbc操作的支持 Spring ORM spring对orm的支持: 既可以与hibernate整合,[session] 也可以使用spring的对hibernate操作的封装 Spring AOP 切面编程 SpringEE Spring对javaEE其他模块的支持 Core模块快速入门 搭建配置环境 引入jar包: 涉及到Spring core的开发jar包有五个: commons-logging-1.1.3.jar 日志 spring-beans-3.2.5.RELEASE.jar bean节点 spring-context-3.2.5.RELEASE.jar spring上下文节点 spring-core-3.2.5.RELEASE.jar spring核心功能 spring-expression-3.2.5.RELEASE.jar spring表达式相关表 编写配置文件: Spring核心的配置文件applicationContext.xml或者叫bean.xml 那这个配置文件怎么写呢？？一般地，我们都知道框架的配置文件都是有约束的…我们可以在spring-framework-3.2.5.RELEASE\docs\spring-framework-reference\htmlsingle\index.html找到XML配置文件的约束 1234567891011&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;/beans&gt; 前面在介绍Spring模块的时候已经说了，Core模块是：IOC容器，解决对象创建和之间的依赖关系。 因此Core模块主要是学习如何得到IOC容器，通过IOC容器来创建对象、解决对象之间的依赖关系、IOC细节。 得到Spring容器对象[IOC]容器 Bean工厂，BeanFactory[功能简单] 应用上下文，ApplicationContext[功能强大，一般我们使用这个] 加载配置文件 通过XmlBeanFactory+配置文件来创建IOC容器 12345//加载Spring的资源文件Resource resource = new ClassPathResource("applicationContext.xml");//创建IOC容器对象【IOC容器=工厂类+applicationContext.xml】BeanFactory beanFactory = new XmlBeanFactory(resource); 直接通过ClassPathXmlApplicationContext对象来获取 12// 得到IOC容器对象ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); 在Spring中总体来看可以通过三种方式来配置对象: 使用XML文件配置 使用注解来配置 使用JavaConfig来配置 XML配置方式 在上面我们已经可以得到IOC对象了. 接下来就是在applicationContext.xml文件中配置信息[让IOC容器根据applicationContext.xml文件来创建对象] 首先我们有个JavaBean的类 12345678910111213141516171819202122public class User &#123; private String id; private String username; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125;&#125; 以前我们是通过new User的方法创建对象的 1User user = new User; 现在我们有了IOC容器, 可以让IOC容器帮我们创建对象了. 在applicationContext.xml文件中配置对应的信息就行了 123456&lt;!-- 使用bean节点来创建对象 id属性标识着对象 name属性代表着要创建对象的类全名 --&gt;&lt;bean id="user" class="User"/&gt; 通过IOC容器对象获取对象 在外界通过IOC容器对象得到User对象 1User user = (User) ac.getBean("user"); 上面我们使用的是IOC通过无参构造函数来创建对象, 我们来回顾一下一般有几种创建对象的方式： 无参构造函数创建对象 带参数的构造函数创建对象 工厂创建对象 静态方法创建对象 非静态方法创建对象 使用无参的构造函数创建对象我们已经会了, 接下来我们看看使用剩下的IOC容器是怎么创建对象的. 带参数的构造函数创建对象 首先, JavaBean要提供带参数的构造函数 1234public User(String id, String username) &#123; this.id = id; this.username = username; &#125; 接下来, 关键是怎么配置xml文件 12345&lt;bean id="user" class="User"&gt; &lt;!--通过constructor这个节点来指定构造函数的参数类型、名称、第几个--&gt; &lt;constructor-arg index="0" name="id" type="java.lang.String" value="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" name="username" type="java.lang.String" value="zhongfucheng"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 在constructor上如果构造函数的值是一个对象，而不是一个普通类型的值，我们就需要用到ref属性了，而不是value属性 比如说：我在User对象上维护了Person对象的值，想要在构造函数中初始化它。因此，就需要用到ref属性了 1234567&lt;bean id="person" class="Person"&gt;&lt;/bean&gt; &lt;bean id="user" class="User" &gt; &lt;!--通过constructor这个节点来指定构造函数的参数类型、名称、第几个--&gt; &lt;constructor-arg index="0" name="id" type="java.lang.String" value="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" name="username" type="java.lang.String" ref="person"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 工厂静态方法创建对象 首先, 使用一个工厂的静态方法返回一个对象 123456public class Factory &#123; public static User getBean() &#123; return new User(); &#125;&#125; 配置文件中使用工厂的静态方法返回对象 1234&lt;!--工厂静态方法创建对象，直接使用class指向静态类，指定静态方法就行了--&gt; &lt;bean id="user" class="Factory" factory-method="getBean" &gt; &lt;/bean&gt; 工厂非静态方法创建对象 首先, 也是通过工厂的非非静态方法来得到一个对象 123456public class Factory &#123; public User getBean() &#123; return new User(); &#125;&#125; 配置文件中使用工厂的非静态方法返回对象 12345&lt;!--首先创建工厂对象--&gt; &lt;bean id="factory" class="Factory"/&gt; &lt;!--指定工厂对象和工厂方法--&gt; &lt;bean id="user" class="User" factory-bean="factory" factory-method="getBean"/&gt; 装载集合 如果对象上的属性或者构造函数拥有集合的时候, 而我们又需要为集合赋值, 那么怎么办？ 在构造函数上，普通类型 12345678 &lt;bean id="userService" class="bb.UserService" &gt; &lt;constructor-arg &gt; &lt;list&gt; //普通类型 &lt;value&gt;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; 在属性上,引用类型 123456&lt;property name="userDao"&gt; &lt;list&gt; &lt;ref&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; 注解方式 通过注解来配置信息就是为了简化IOC容器的配置, 注解可以把对象添加到IOC容器中, 处理对象依赖关系, 我们来看看怎么用吧： 使用注解步骤： 1. 先引入context名称空间 xmlns:context=”http://www.springframework.org/schema/context&quot; 2. 开启注解扫描器 &lt;context:component-scan base-package=&quot;&quot;&gt;&lt;/context:component-scan&gt; 第二种方法:也可以通过自定义扫描类以@CompoentScan修饰来扫描IOC容器的bean对象。。如下代码: 12345678910//表明该类是配置类@Configuration//启动扫描器，扫描bb包下的 //也可以指定多个基础包 //也可以指定类型@ComponentScan("bb")public class AnnotationScan &#123;&#125; 在使用@ComponentScan()这个注解的时候，在测试类上需要@ContextConfiguration这个注解来加载配置类 @ContextConfiguration这个注解又在Spring的test包下 创建对象以及处理对象依赖关系，相关的注解： @ComponentScan扫描器 @Configuration表明该类是配置类 @Component 指定把一个对象加入IOC容器—&gt;@Name也可以实现相同的效果【一般少用】 @Repository 作用同@Component； 在持久层使用 @Service 作用同@Component； 在业务逻辑层使用 @Controller 作用同@Component； 在控制层使用 @Resource 依赖关系 如果@Resource不指定值，那么就根据类型来找，相同的类型在IOC容器中不能有两个 如果@Resource指定了值，那么就根据名字来找 测试代码: UserDao 12345678package aa;import org.springframework.stereotype.Repository;//把对象添加到容器中,首字母会小写@Repositorypublic class UserDao &#123; public void save() &#123; System.out.println("DB:保存用户"); &#125;&#125; userService 1234567891011121314151617181920212223package aa;import org.springframework.stereotype.Service;import javax.annotation.Resource;//把UserService对象添加到IOC容器中,首字母会小写@Servicepublic class UserService &#123; //如果@Resource不指定值，那么就根据类型来找---&gt;UserDao....当然了，IOC容器不能有两个UserDao类型的对象 //@Resource //如果指定了值，那么Spring就在IOC容器找有没有id为userDao的对象。 @Resource(name = "userDao") private UserDao userDao; public void save() &#123; userDao.save(); &#125;&#125; useraction 123456789101112131415161718package aa;import org.springframework.stereotype.Controller;import javax.annotation.Resource;//把对象添加到IOC容器中,首字母会小写@Controllerpublic class UserAction &#123; @Resource(name = "userService") private UserService userService; public String execute() &#123; userService.save(); return null; &#125;&#125; 测试 1234567891011121314151617package aa;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main(String[] args) &#123; // 创建容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext("aa/applicationContext.xml"); UserAction userAction = (UserAction) ac.getBean("userAction"); userAction.execute(); &#125;&#125; 通过java方式 由于Spring的自动装配并不能将第三方库组件装配到应用中, 于是需要显式装配配置. 显示装配有两种方式 通过java代码装配bean 通过XML装配bean Spring In Action作者首推使用自动装配的功能，而后是通过java代码配置bean，最后才用XML文件配置的方式.. 那么怎么通过java代码来配置Bean呢？？ 编写一个java类，使用@Configuration修饰该类 被@Configuration修饰的类就是配置类 编写配置类: 1234@org.springframework.context.annotation.Configuration public class Configuration &#123; &#125; 使用配置类创建bean: 使用@Bean来修饰方法，该方法返回一个对象 不管方法体内的对象是怎么创建的，Spring可以获取得到对象就行了 Spring内部会将该对象加入到Spring容器中 容器中bean的ID默认为方法名 123456789101112@org.springframework.context.annotation.Configurationpublic class Configuration &#123; @Bean public UserDao userDao() &#123; UserDao userDao = new UserDao(); System.out.println("我是在configuration中的"+userDao); return userDao; &#125;&#125; 测试代码：要使用@ContextConfiguration加载配置类的信息[引入test包] 12345678910111213141516171819202122package bb;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;//加载配置类的信息@ContextConfiguration(classes = Configuration.class)public class Test2 &#123; @Test public void test33() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bb/bean.xml"); UserDao userDao = (UserDao) ac.getBean("userDao"); System.out.println(userDao); &#125;&#125; 三种方式混合 注解和XML配置是可以混合使用的，JavaConfig和XML也是可以混合使用的 如果JavaConfig的配置类是分散的，我们一般再创建一个更高级的配置类（root），然后使用@Import来将配置类进行组合如果XML的配置文件是分散的，我们也是创建一个更高级的配置文件（root），然后使用来将配置文件组合 在JavaConfig引用XML 使用@ImportResource() 在XML引用JavaConfig 使用节点就行了 bean对象创建细节 scope属性 指定scope属性，IOC容器就知道创建对象的时候是单例还是多例的了 ​ 属性的值就只有两个：单例(singleton)/多例(prototype) 当我们使用singleton的时候, 从IOC容器获取的对象都是同一个 当我们使用prototype的时候, 从IOC容器获取的对象都是不同的 scope属性除了控制对象是单例还是多例的，还控制着对象创建的时间！ 我们在User的构造函数中打印出一句话，就知道User对象是什么时候创建了。 1234public User() &#123; System.out.println("我是User，我被创建了"); &#125; 当使用singleton的时候，对象在IOC容器之前就已经创建了 当使用prototype的时候，对象在使用的时候才创建 lazy-init属性 lazy-init属性只对singleton[单例]的对象有效…..lazy-init默认为false…. 有的时候，可能我们想要对象在使用的时候才创建，那么将lazy-init设置为ture就行了 init-method和destroy-method 如果我们想要对象在创建后, 执行某个方法, 我们指定为init-method属性就行了 如果我们想要IOC容器销毁后, 执行某个方法, 我们指定destroy-method属性就行了 1&lt;bean id="user" class="User" scope="singleton" lazy-init="true" init-method="" destroy-method=""/&gt; bean创建细节总结 /** * 1) 对象创建： 单例/多例 * scope=”singleton”, 默认值， 即 默认是单例 [service/dao/工具类] * scope=”prototype”, 多例； [Action对象] * * 2) 什么时候创建? * scope=”prototype” 在用到对象的时候，才创建对象。 * scope=”singleton” 在启动(容器初始化之前)， 就已经创建了bean，且整个应用只有一个。 * 3)是否延迟创建 * lazy-init=”false” 默认为false, 不延迟创建，即在启动时候就创建对象 * lazy-init=”true” 延迟初始化， 在用到对象的时候才创建对象 * （只对单例有效） * 4) 创建对象之后，初始化/销毁 * init-method=”init_user” [对应对象的init_user方法，在对象创建之后执行 ] * destroy-method=”destroy_user” [在调用容器对象的destroy方法时候执行，(容器用实现类)] */]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
